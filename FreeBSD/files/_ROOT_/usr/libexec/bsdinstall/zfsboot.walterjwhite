#!/bin/sh
#
#
#
#

BSDCFG_SHARE="/usr/share/bsdconfig"
. $BSDCFG_SHARE/common.subr || exit 1
f_dprintf "%s: loading includes..." "$0"
f_include $BSDCFG_SHARE/device.subr
f_include $BSDCFG_SHARE/dialog.subr
f_include $BSDCFG_SHARE/password/password.subr
f_include $BSDCFG_SHARE/variable.subr


#
#
: ${ZFSBOOT_POOL_NAME:=zroot}

#
#
: ${ZFSBOOT_POOL_SIZE=}

#
#
: ${ZFSBOOT_POOL_CREATE_OPTIONS:=-O compress=lz4 -O atime=off}

#
#
: ${ZFSBOOT_BEROOT_NAME:=ROOT}

#
#
: ${ZFSBOOT_BOOTFS_NAME:=default}

#
#
: ${ZFSBOOT_VDEV_TYPE:=stripe}

#
#
: ${ZFSBOOT_FORCE_4K_SECTORS:=1}

#
#
: ${ZFSBOOT_GELI_ENCRYPTION=}

#
#
: ${ZFSBOOT_GELI_KEY_FILE:=/boot/encryption.key}

#
#
: ${ZFSBOOT_BOOT_POOL=}

#
#
: ${ZFSBOOT_BOOT_POOL_CREATE_OPTIONS:=}

#
#
: ${ZFSBOOT_BOOT_POOL_NAME:=bootpool}

#
#
: ${ZFSBOOT_BOOT_POOL_SIZE:=2g}

#
#
: ${ZFSBOOT_DISKS:=}

#
#
: ${ZFSBOOT_PARTITION_SCHEME:=}

#
#
: ${ZFSBOOT_BOOT_TYPE:=}

#
#
: ${ZFSBOOT_SWAP_SIZE:=2g}

#
#
: ${ZFSBOOT_SWAP_ENCRYPTION=}

#
#
: ${ZFSBOOT_SWAP_MIRROR=}

#
#
#
f_isset ZFSBOOT_DATASETS || ZFSBOOT_DATASETS="

	/$ZFSBOOT_BEROOT_NAME				mountpoint=none
	/$ZFSBOOT_BEROOT_NAME/$ZFSBOOT_BOOTFS_NAME	mountpoint=/

	/home		mountpoint=/home


	/usr		mountpoint=/usr,canmount=off

	/usr/ports	setuid=off

	/usr/src

	/var		mountpoint=/var,canmount=off
	/var/audit	exec=off,setuid=off
	/var/crash	exec=off,setuid=off
	/var/log	exec=off,setuid=off
	/var/mail	atime=on
	/var/tmp	setuid=off
" # END-QUOTE

#
#
: ${ZFSBOOT_CONFIRM_LAYOUT:=1}


#
#
FSTAB_FMT="%s\t\t%s\t%s\t%s\t\t%s\t%s\n"

#
#
COPY='cp "%s" "%s"'
CHMOD_MODE='chmod %s "%s"'
DD_WITH_OPTIONS='dd if="%s" of="%s" %s'
ECHO_APPEND='echo "%s" >> "%s"'
ECHO_OVERWRITE='echo "%s" > "%s"'
GELI_ATTACH='geli attach -j - -k "%s" "%s"'
GELI_ATTACH_NOKEY='geli attach -j - "%s"'
GELI_DETACH_F='geli detach -f "%s"'
GELI_PASSWORD_INIT='geli init -b -B "%s" -e %s -J - -K "%s" -l 256 -s 4096 "%s"'
GELI_PASSWORD_GELIBOOT_INIT='geli init -bg -e %s -J - -l 256 -s 4096 "%s"'
GPART_ADD_ALIGN='gpart add %s -t %s "%s"'
GPART_ADD_ALIGN_INDEX='gpart add %s -i %s -t %s "%s"'
GPART_ADD_ALIGN_INDEX_WITH_SIZE='gpart add %s -i %s -t %s -s %s "%s"'
GPART_ADD_ALIGN_LABEL='gpart add %s -l %s -t %s "%s"'
GPART_ADD_ALIGN_LABEL_WITH_SIZE='gpart add %s -l %s -t %s -s %s "%s"'
GPART_BOOTCODE='gpart bootcode -b "%s" "%s"'
GPART_BOOTCODE_PART='gpart bootcode -b "%s" -p "%s" -i %s "%s"'
GPART_BOOTCODE_PARTONLY='gpart bootcode -p "%s" -i %s "%s"'
GPART_CREATE='gpart create -s %s "%s"'
GPART_DESTROY_F='gpart destroy -F "%s"'
GPART_SET_ACTIVE='gpart set -a active -i %s "%s"'
GPART_SET_LENOVOFIX='gpart set -a lenovofix "%s"'
GPART_SET_PMBR_ACTIVE='gpart set -a active "%s"'
GRAID_DELETE='graid delete "%s"'
KLDLOAD='kldload %s'
LN_SF='ln -sf "%s" "%s"'
MKDIR_P='mkdir -p "%s"'
MOUNT_TYPE='mount -t %s "%s" "%s"'
NEWFS_ESP='newfs_msdos "%s"'
PRINTF_CONF="printf '%s=\"%%s\"\\\n' %s >> \"%s\""
PRINTF_FSTAB='printf "$FSTAB_FMT" "%s" "%s" "%s" "%s" "%s" "%s" >> "%s"'
SHELL_TRUNCATE=':> "%s"'
SWAP_GMIRROR_LABEL='gmirror label swap %s'
SYSCTL_ZFS_MIN_ASHIFT_12='sysctl vfs.zfs.min_auto_ashift=12'
UMOUNT='umount "%s"'
ZFS_CREATE_WITH_OPTIONS='zfs create %s "%s"'
ZFS_MOUNT='zfs mount "%s"'
ZFS_SET='zfs set "%s" "%s"'
ZFS_UNMOUNT='zfs unmount "%s"'
ZPOOL_CREATE_WITH_OPTIONS='zpool create %s "%s" %s %s'
ZPOOL_DESTROY='zpool destroy "%s"'
ZPOOL_EXPORT='zpool export "%s"'
ZPOOL_EXPORT_F='zpool export -f "%s"'
ZPOOL_IMPORT_WITH_OPTIONS='zpool import %s "%s"'
ZPOOL_LABELCLEAR_F='zpool labelclear -f "%s"'
ZPOOL_SET='zpool set %s "%s"'

#
#
hline_alnum_arrows_punc_tab_enter="Use alnum, arrows, punctuation, TAB or ENTER"
hline_arrows_space_tab_enter="Use arrows, SPACE, TAB or ENTER"
hline_arrows_tab_enter="Press arrows, TAB or ENTER"
msg_an_unknown_error_occurred="An unknown error occurred"
msg_back="Back"
msg_cancel="Cancel"
msg_change_selection="Change Selection"
msg_configure_options="Configure Options:"
msg_detailed_disk_info="gpart(8) show %s:\n%s\n\ncamcontrol(8) inquiry %s:\n%s\n\n\ncamcontrol(8) identify %s:\n%s\n"
msg_disk_info="Disk Info"
msg_disk_info_help="Get detailed information on disk device(s)"
msg_disk_plural="disks"
msg_disk_singular="disk"
msg_encrypt_disks="Encrypt Disks?"
msg_encrypt_disks_help="Use geli(8) to encrypt all data partitions"
msg_error="Error"
msg_force_4k_sectors="Force 4K Sectors?"
msg_force_4k_sectors_help="Align partitions to 4K sector boundries and set vfs.zfs.min_auto_ashift=12"
msg_freebsd_installer="$OSNAME Installer"
msg_geli_password="Enter a strong passphrase, used to protect your encryption keys. You will be required to enter this passphrase each time the system is booted"
msg_geli_setup="Initializing encryption on selected disks,\n this will take several seconds per disk"
msg_install="Install"
msg_install_desc="Proceed with Installation"
msg_install_help="Create ZFS boot pool with displayed options"
msg_invalid_boot_pool_size="Invalid boot pool size \`%s'"
msg_invalid_disk_argument="Invalid disk argument \`%s'"
msg_invalid_index_argument="Invalid index argument \`%s'"
msg_invalid_pool_size="Invalid pool size \`%s'"
msg_invalid_swap_size="Invalid swap size \`%s'"
msg_invalid_virtual_device_type="Invalid Virtual Device type \`%s'"
msg_last_chance_are_you_sure="Last Chance! Are you sure you want to destroy\nthe current contents of the following disks:\n\n   %s"
msg_last_chance_are_you_sure_color='\\ZrLast Chance!\\ZR Are you \\Z1sure\\Zn you want to \\Zr\\Z1destroy\\Zn\nthe current contents of the following disks:\n\n   %s'
msg_mirror_desc="Mirror - n-Way Mirroring"
msg_mirror_help="[2+ Disks] Mirroring provides the best performance, but the least storage"
msg_missing_disk_arguments="missing disk arguments"
msg_missing_one_or_more_scripted_disks="Missing one or more scripted disks!"
msg_no="NO"
msg_no_disks_present_to_configure="No disk(s) present to configure"
msg_no_disks_selected="No disks selected."
msg_not_enough_disks_selected="Not enough disks selected. (%u < %u minimum)"
msg_null_disk_argument="NULL disk argument"
msg_null_index_argument="NULL index argument"
msg_null_poolname="NULL poolname"
msg_odd_disk_selected="An even number of disks must be selected to create a RAID 1+0. (%u selected)"
msg_ok="OK"
msg_partition_scheme="Partition Scheme"
msg_partition_scheme_help="Select partitioning scheme. GPT is recommended."
msg_please_enter_a_name_for_your_zpool="Please enter a name for your zpool:"
msg_please_enter_amount_of_swap_space="Please enter amount of swap space (SI-Unit suffixes\nrecommended; e.g., \`2g' for 2 Gigabytes):"
msg_please_select_one_or_more_disks="Please select one or more disks to create a zpool:"
msg_pool_name="Pool Name"
msg_pool_name_cannot_be_empty="Pool name cannot be empty."
msg_pool_name_help="Customize the name of the zpool to be created (Required)"
msg_pool_type_disks="Pool Type/Disks:"
msg_pool_type_disks_help="Choose type of ZFS Virtual Device and disks to use (Required)"
msg_processing_selection="Processing selection..."
msg_raid10_desc="RAID 1+0 - n x 2-Way Mirrors"
msg_raid10_help="[4+ Disks] Striped Mirrors provides the best performance, but the least storage"
msg_raidz1_desc="RAID-Z1 - Single Redundant RAID"
msg_raidz1_help="[3+ Disks] Withstand failure of 1 disk. Recommended for: 3, 5 or 9 disks"
msg_raidz2_desc="RAID-Z2 - Double Redundant RAID"
msg_raidz2_help="[4+ Disks] Withstand failure of 2 disks. Recommended for: 4, 6 or 10 disks"
msg_raidz3_desc="RAID-Z3 - Triple Redundant RAID"
msg_raidz3_help="[5+ Disks] Withstand failure of 3 disks. Recommended for: 5, 7 or 11 disks"
msg_rescan_devices="Rescan Devices"
msg_rescan_devices_help="Scan for device changes"
msg_select="Select"
msg_select_a_disk_device="Select a disk device"
msg_select_virtual_device_type="Select Virtual Device type:"
msg_stripe_desc="Stripe - No Redundancy"
msg_stripe_help="[1+ Disks] Striping provides maximum storage but no redundancy"
msg_swap_encrypt="Encrypt Swap?"
msg_swap_encrypt_help="Encrypt swap partitions with temporary keys, discarded on reboot"
msg_swap_invalid="The selected swap size (%s) is invalid. Enter a number optionally followed by units. Example: 2G"
msg_swap_mirror="Mirror Swap?"
msg_swap_mirror_help="Mirror swap partitions for redundancy, breaks crash dumps"
msg_swap_size="Swap Size"
msg_swap_size_help="Customize how much swap space is allocated to each selected disk"
msg_swap_toosmall="The selected swap size (%s) is too small. Please enter a value greater than 100MB or enter 0 for no swap"
msg_these_disks_are_too_small="These disks are smaller than the amount of requested\nswap (%s) and/or geli(8) (%s) partitions, which would\ntake 100%% or more of each of the following selected disks:\n\n  %s\n\nRecommend changing partition size(s) and/or selecting a\ndifferent set of disks."
msg_unable_to_get_disk_capacity="Unable to get disk capacity of \`%s'"
msg_unsupported_partition_scheme="%s is an unsupported partition scheme"
msg_user_cancelled="User Cancelled."
msg_yes="YES"
msg_zfs_configuration="ZFS Configuration"


#
#
dialog_menu_main() {
	local title="$DIALOG_TITLE"
	local btitle="$DIALOG_BACKTITLE"
	local prompt="$msg_configure_options"
	local force4k="$msg_no"
	local usegeli="$msg_no"
	local swapgeli="$msg_no"
	local swapmirror="$msg_no"
	[ "$ZFSBOOT_FORCE_4K_SECTORS" ] && force4k="$msg_yes"
	[ "$ZFSBOOT_GELI_ENCRYPTION" ] && usegeli="$msg_yes"
	[ "$ZFSBOOT_SWAP_ENCRYPTION" ] && swapgeli="$msg_yes"
	[ "$ZFSBOOT_SWAP_MIRROR" ] && swapmirror="$msg_yes"
	local disks n disks_grammar
	f_count n $ZFSBOOT_DISKS
	{ [ $n -eq 1 ] && disks_grammar=$msg_disk_singular; } ||
		disks_grammar=$msg_disk_plural                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  # grammar
	local menu_list="
		'>>> $msg_install'      '$msg_install_desc'
		                        '$msg_install_help'
		'T $msg_pool_type_disks'
		               '$ZFSBOOT_VDEV_TYPE: $n $disks_grammar'
		               '$msg_pool_type_disks_help'
		'- $msg_rescan_devices' '*'
		                        '$msg_rescan_devices_help'
		'- $msg_disk_info'      '*'
		                        '$msg_disk_info_help'
		'N $msg_pool_name'      '$ZFSBOOT_POOL_NAME'
		                        '$msg_pool_name_help'
		'4 $msg_force_4k_sectors'
		                        '$force4k'
		                        '$msg_force_4k_sectors_help'
		'E $msg_encrypt_disks'  '$usegeli'
		                        '$msg_encrypt_disks_help'
		'P $msg_partition_scheme'
		               '$ZFSBOOT_PARTITION_SCHEME ($ZFSBOOT_BOOT_TYPE)'
		               '$msg_partition_scheme_help'
		'S $msg_swap_size'      '$ZFSBOOT_SWAP_SIZE'
		                        '$msg_swap_size_help'
		'M $msg_swap_mirror'    '$swapmirror'
		                        '$msg_swap_mirror_help'
		'W $msg_swap_encrypt'   '$swapgeli'
		                        '$msg_swap_encrypt_help'
	" # END-QUOTE
	local defaultitem=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               # Calculated below
	local hline="$hline_alnum_arrows_punc_tab_enter"

	local height width rows
	eval f_dialog_menu_with_help_size height width rows \
		\"\$title\" \"\$btitle\" \"\$prompt\" \"\$hline\" $menu_list

	f_dialog_default_fetch defaultitem

	local menu_choice
	menu_choice=$(
		eval $DIALOG \
			--title \"\$title\" \
			--backtitle \"\$btitle\" \
			--hline \"\$hline\" \
			--item-help \
			--ok-label \"\$msg_select\" \
			--cancel-label \"\$msg_cancel\" \
			--default-item \"\$defaultitem\" \
			--menu \"\$prompt\" \
			$height $width $rows \
			$menu_list \
			2>&1 >&$DIALOG_TERMINAL_PASSTHRU_FD
	)
	local retval=$?
	f_dialog_data_sanitize menu_choice
	f_dialog_menutag_store "$menu_choice"

	[ $retval -eq $DIALOG_OK ] && f_dialog_default_store "$menu_choice"

	return $retval
}

#
#
dialog_last_chance() {
	local title="$DIALOG_TITLE"
	local btitle="$DIALOG_BACKTITLE"
	local prompt # Calculated below
	local hline="$hline_arrows_tab_enter"

	local height=8 width=50 prefix="   "
	local plen=${#prefix} list= line=
	local max_width=$(($width - 3 - $plen))

	local yes no defaultno extra_args format
	if [ "$USE_XDIALOG" ]; then
		yes=ok no=cancel defaultno=default-no
		extra_args="--wrap --left"
		format="$msg_last_chance_are_you_sure"
	else
		yes=yes no=no defaultno=defaultno
		extra_args="--colors --cr-wrap"
		format="$msg_last_chance_are_you_sure_color"
	fi

	local disk line_width
	for disk in $*; do
		if [ "$line" ]; then
			line_width=${#line}
		else
			line_width=$plen
		fi
		line_width=$(($line_width + 1 + ${#disk}))
		if [ $line_width -gt $max_width ]; then
			list="$list$line\n"
			line="$prefix"
			height=$(($height + 1))
		fi
		line="$line $disk"
	done
	if [ "${line#$prefix}" ]; then
		list="$list$line"
		height=$(($height + 1))
	fi

	[ "$USE_XDIALOG" ] && height=$(($height + $height / 5 + 3))

	prompt=$(printf "$format" "$list")
	f_dprintf "%s: Last Chance!" "$0"
	$DIALOG \
		--title "$title" \
		--backtitle "$btitle" \
		--hline "$hline" \
		--$defaultno \
		--$yes-label "$msg_yes" \
		--$no-label "$msg_no" \
		$extra_args \
		--yesno "$prompt" $height $width
}

#
#
dialog_menu_layout() {
	local funcname=dialog_menu_layout
	local title="$DIALOG_TITLE"
	local btitle="$DIALOG_BACKTITLE"
	local vdev_prompt="$msg_select_virtual_device_type"
	local disk_prompt="$msg_please_select_one_or_more_disks"
	local vdev_menu_list="
		'stripe' '$msg_stripe_desc' '$msg_stripe_help'
		'mirror' '$msg_mirror_desc' '$msg_mirror_help'
		'raid10' '$msg_raid10_desc' '$msg_raid10_help'
		'raidz1' '$msg_raidz1_desc' '$msg_raidz1_help'
		'raidz2' '$msg_raidz2_desc' '$msg_raidz2_help'
		'raidz3' '$msg_raidz3_desc' '$msg_raidz3_help'
	" # END-QUOTE
	local disk_check_list=                                                                                                                                                                                                                                                                                                          # Calculated below
	local vdev_hline="$hline_arrows_tab_enter"
	local disk_hline="$hline_arrows_space_tab_enter"

	case "$ZFSBOOT_VDEV_TYPE" in
	stripe | mirror | raid10 | raidz1 | raidz2 | raidz3) : known good ;;
	*)
		f_dprintf "%s: Invalid virtual device type \`%s'" \
			$funcname "$ZFSBOOT_VDEV_TYPE"
		f_show_err "$msg_invalid_virtual_device_type" \
			"$ZFSBOOT_VDEV_TYPE"
		f_interactive || return $FAILURE
		;;
	esac

	local vheight vwidth vrows
	eval f_dialog_menu_with_help_size vheight vwidth vrows \
		\"\$title\" \"\$btitle\" \"\$vdev_prompt\" \"\$vdev_hline\" \
		$vdev_menu_list

	local disks=
	debug= f_device_find "" $DEVICE_TYPE_DISK disks

	local disk name new_list=
	for disk in $disks; do
		debug= $disk get name name
		case "$name" in
		md[0-9]*) f_mounted -b "/dev/$name" && continue ;;
		esac
		new_list="$new_list $disk"
	done
	disks="${new_list# }"

	local avail_disks=
	for disk in $disks; do
		debug= $disk get name name
		geom disk list $name | awk '$1 == "Mode:" && $2 != "r0w0e0" { exit 1 }'
		[ $? -eq 0 ] && avail_disks="$avail_disks $disk"
	done
	disks="${avail_disks# }"

	if [ "$debug" ]; then
		local disk_names=
		for disk in $disks; do
			debug= $disk get name name
			disk_names="$disk_names $name"
		done
		f_dprintf "$funcname: disks=[%s]" "${disk_names# }"
	fi

	if [ ! "$disks" ]; then
		f_dprintf "No disk(s) present to configure"
		f_show_err "$msg_no_disks_present_to_configure"
		return $FAILURE
	fi

	f_device_sort_by name disks disks

	#
	#
	local vardisk ndisks onoff selections vdev_choice breakout device
	local valid_disks all_valid want_disks desc height width rows
	while :; do
		#
		#
		if f_interactive && [ "$ZFSBOOT_CONFIRM_LAYOUT" ]; then
			vdev_choice=$(
				eval $DIALOG \
					--title \"\$title\" \
					--backtitle \"\$btitle\" \
					--hline \"\$vdev_hline\" \
					--ok-label \"\$msg_ok\" \
					--cancel-label \"\$msg_cancel\" \
					--item-help \
					--default-item \"\$ZFSBOOT_VDEV_TYPE\" \
					--menu \"\$vdev_prompt\" \
					$vheight $vwidth $vrows \
					$vdev_menu_list \
					2>&1 >&$DIALOG_TERMINAL_PASSTHRU_FD
			) || return $?
			f_dialog_data_sanitize vdev_choice

			ZFSBOOT_VDEV_TYPE="$vdev_choice"
			f_dprintf "$funcname: ZFSBOOT_VDEV_TYPE=[%s]" \
				"$ZFSBOOT_VDEV_TYPE"
		fi

		want_disks=0
		case "$ZFSBOOT_VDEV_TYPE" in
		stripe) want_disks=1 ;;
		mirror) want_disks=2 ;;
		raid10) want_disks=4 ;;
		raidz1) want_disks=3 ;;
		raidz2) want_disks=4 ;;
		raidz3) want_disks=5 ;;
		esac

		#
		#
		valid_disks= all_valid=${ZFSBOOT_DISKS:+1} # optimism
		for disk in $ZFSBOOT_DISKS; do
			if debug= f_device_find -1 \
				$disk $DEVICE_TYPE_DISK device; then
				valid_disks="$valid_disks $disk"
				continue
			fi
			f_dprintf "$funcname: \`%s' is not a real disk" "$disk"
			all_valid=
		done
		if [ ! "$all_valid" ]; then
			if [ "$ZFSBOOT_DISKS" ]; then
				f_show_err \
					"$msg_missing_one_or_more_scripted_disks"
			else
				f_dprintf "No disks selected."
				f_interactive ||
					f_show_err "$msg_no_disks_selected"
			fi
			f_interactive || return $FAILURE
		fi
		ZFSBOOT_DISKS="${valid_disks# }"

		#
		#
		if ! f_interactive || [ ! "$ZFSBOOT_CONFIRM_LAYOUT" ]; then
			f_count ndisks $ZFSBOOT_DISKS
			[ $ndisks -ge $want_disks ] && break # to success

			f_dprintf "$funcname: %s: %s (%u < %u minimum)" \
				"$ZFSBOOT_VDEV_TYPE" \
				"Not enough disks selected." \
				$ndisks $want_disks
			f_interactive || return $FAILURE
			msg_yes="$msg_change_selection" msg_no="$msg_cancel" \
				f_yesno "%s: $msg_not_enough_disks_selected" \
				"$ZFSBOOT_VDEV_TYPE" $ndisks $want_disks ||
				return $FAILURE
		fi

		#
		#
		breakout=
		while :; do
			for disk in $disks; do
				f_isset _${disk}_status && setvar _${disk}_status
			done

			for disk in $ZFSBOOT_DISKS; do
				debug= f_device_find -1 \
					$disk $DEVICE_TYPE_DISK disk
				f_isset _${disk}_status ||
					local _${disk}_status
				setvar _${disk}_status on
			done

			disk_check_list=
			for disk in $disks; do
				desc=
				$disk get name name
				$disk get desc desc
				f_shell_escape "$desc" desc
				f_getvar _${disk}_status:-off onoff
				disk_check_list="$disk_check_list
					$name '$desc' $onoff"
			done

			eval f_dialog_checklist_size height width rows \
				\"\$title\" \"\$btitle\" \"\$prompt\" \
				\"\$hline\" $disk_check_list

			selections=$(
				eval $DIALOG \
					--title \"\$DIALOG_TITLE\" \
					--backtitle \"\$DIALOG_BACKTITLE\" \
					--separate-output \
					--hline \"\$hline\" \
					--ok-label \"\$msg_ok\" \
					--cancel-label \"\$msg_back\" \
					--checklist \"\$prompt\" \
					$height $width $rows \
					$disk_check_list \
					2>&1 >&$DIALOG_TERMINAL_PASSTHRU_FD
			) || break
			f_dialog_data_sanitize selections

			ZFSBOOT_DISKS="$selections"
			f_dprintf "$funcname: ZFSBOOT_DISKS=[%s]" \
				"$ZFSBOOT_DISKS"

			f_count ndisks $ZFSBOOT_DISKS

			if [ "$ZFSBOOT_VDEV_TYPE" == "raid10" ] &&
				[ $(($ndisks % 2)) -ne 0 ]; then
				f_dprintf "$funcname: %s: %s (%u %% 2 = %u)" \
					"$ZFSBOOT_VDEV_TYPE" \
					"Number of disks not even:" \
					$ndisks $(($ndisks % 2))
				msg_yes="$msg_change_selection" \
					msg_no="$msg_cancel" \
					f_yesno "%s: $msg_odd_disk_selected" \
					"$ZFSBOOT_VDEV_TYPE" $ndisks ||
					break
				continue
			fi

			[ $ndisks -ge $want_disks ] &&
				breakout=break && break

			f_dprintf "$funcname: %s: %s (%u < %u minimum)" \
				"$ZFSBOOT_VDEV_TYPE" \
				"Not enough disks selected." \
				$ndisks $want_disks
			msg_yes="$msg_change_selection" msg_no="$msg_cancel" \
				f_yesno "%s: $msg_not_enough_disks_selected" \
				"$ZFSBOOT_VDEV_TYPE" $ndisks $want_disks ||
				break
		done
		[ "$breakout" = "break" ] && break
		[ "$ZFSBOOT_CONFIRM_LAYOUT" ] || return $FAILURE
	done

	return $DIALOG_OK
}

#
#
#
zfs_create_diskpart() {
	local funcname=zfs_create_diskpart
	local disk="$1" index="$2"

	if [ ! "$disk" ]; then
		f_dprintf "$funcname: NULL disk argument"
		msg_error="$msg_error: $funcname" \
			f_show_err "$msg_null_disk_argument"
		return $FAILURE
	fi
	if [ "${disk#*[$IFS]}" != "$disk" ]; then
		f_dprintf "$funcname: Invalid disk argument \`%s'" "$disk"
		msg_error="$msg_error: $funcname" \
			f_show_err "$msg_invalid_disk_argument" "$disk"
		return $FAILURE
	fi
	if [ ! "$index" ]; then
		f_dprintf "$funcname: NULL index argument"
		msg_error="$msg_error: $funcname" \
			f_show_err "$msg_null_index_argument"
		return $FAILURE
	fi
	if ! f_isinteger "$index"; then
		f_dprintf "$funcname: Invalid index argument \`%s'" "$index"
		msg_error="$msg_error: $funcname" \
			f_show_err "$msg_invalid_index_argument" "$index"
		return $FAILURE
	fi
	f_dprintf "$funcname: disk=[%s] index=[%s]" "$disk" "$index"

	case "$ZFSBOOT_PARTITION_SCHEME" in
	"" | MBR | GPT*) : known good ;;
	*)
		f_dprintf "$funcname: %s is an unsupported partition scheme" \
			"$ZFSBOOT_PARTITION_SCHEME"
		msg_error="$msg_error: $funcname" f_show_err \
			"$msg_unsupported_partition_scheme" \
			"$ZFSBOOT_PARTITION_SCHEME"
		return $FAILURE
		;;
	esac

	#
	#
	f_dprintf "$funcname: Exporting ZFS pools..."
	zpool list -Ho name | while read z_name; do
		f_eval_catch -d $funcname zpool "$ZPOOL_EXPORT_F" $z_name
	done
	f_dprintf "$funcname: Detaching all GELI providers..."
	geli status | tail -n +2 | while read g_name g_status g_component; do
		f_eval_catch -d $funcname geli "$GELI_DETACH_F" $g_name
	done
	f_dprintf "$funcname: Destroying all data/layouts on \`%s'..." "$disk"
	f_eval_catch -d $funcname gpart "$GPART_DESTROY_F" $disk
	f_eval_catch -d $funcname graid "$GRAID_DELETE" $disk
	f_eval_catch -d $funcname zpool "$ZPOOL_LABELCLEAR_F" /dev/$disk

	f_eval_catch -d $funcname gpart "$GPART_CREATE" gpt $disk
	f_eval_catch -d $funcname gpart "$GPART_DESTROY_F" $disk

	#
	#
	local setsize mbrindex align_small align_big
	#
	#
	if [ "$ZFSBOOT_FORCE_4K_SECTORS" ]; then
		align_small="-a 4k"
		align_big="-a 1m"
	fi

	case "$ZFSBOOT_PARTITION_SCHEME" in
	"" | GPT*)
		f_dprintf "$funcname: Creating GPT layout..."
		#
		#
		f_eval_catch $funcname gpart "$GPART_CREATE" gpt $disk ||
			return $FAILURE

		#
		#
		if [ "$ZFSBOOT_PARTITION_SCHEME" = "GPT + Lenovo Fix" ]; then
			f_eval_catch $funcname gpart "$GPART_SET_LENOVOFIX" \
				$disk || return $FAILURE
		elif [ "$ZFSBOOT_PARTITION_SCHEME" = "GPT + Active" ]; then
			f_eval_catch $funcname gpart "$GPART_SET_PMBR_ACTIVE" \
				$disk || return $FAILURE
		fi

		#
		#
		if [ "$ZFSBOOT_BOOT_TYPE" = "UEFI" -o \
			"$ZFSBOOT_BOOT_TYPE" = "BIOS+UEFI" ]; then
			f_eval_catch -k justaddedpart $funcname gpart \
				"$GPART_ADD_ALIGN_LABEL_WITH_SIZE" \
				"$align_small" efiboot$index efi 260M \
				$disk || return $FAILURE

			if [ -z "$efibootpart" ]; then
				efibootpart="/dev/gpt/efiboot$index"
				f_dprintf "$funcname: configuring ESP at [%s]" \
					"${efibootpart}"

				f_eval_catch $funcname newfs_msdos "$NEWFS_ESP" \
					"$efibootpart" ||
					return $FAILURE
				f_eval_catch $funcname printf "$PRINTF_FSTAB" \
					$efibootpart /boot/efi msdosfs \
					rw 2 2 "$BSDINSTALL_TMPETC/fstab" ||
					return $FAILURE
			fi
		fi

		if [ "$ZFSBOOT_BOOT_TYPE" = "BIOS" -o \
			"$ZFSBOOT_BOOT_TYPE" = "BIOS+UEFI" ]; then
			f_eval_catch $funcname gpart \
				"$GPART_ADD_ALIGN_LABEL_WITH_SIZE" \
				"$align_small" gptboot$index \
				freebsd-boot 512k $disk || return $FAILURE
			if [ "$ZFSBOOT_BOOT_TYPE" = "BIOS" ]; then
				f_eval_catch $funcname gpart \
					"$GPART_BOOTCODE_PART" \
					/boot/pmbr /boot/gptzfsboot 1 \
					$disk || return $FAILURE
			else
				f_eval_catch $funcname gpart \
					"$GPART_BOOTCODE_PART" \
					/boot/pmbr /boot/gptzfsboot 2 \
					$disk || return $FAILURE
			fi
		fi

		if [ "$ZFSBOOT_BOOT_TYPE" = "BIOS+UEFI" ]; then
			if [ "$ZFSBOOT_BOOT_POOL" ]; then
				bootpart=p3 swappart=p4 targetpart=p4
				[ ${swapsize:-0} -gt 0 ] && targetpart=p5
			else
				bootpart=p3 swappart=p3 targetpart=p3
				[ ${swapsize:-0} -gt 0 ] && targetpart=p4
			fi
		else
			if [ "$ZFSBOOT_BOOT_POOL" ]; then
				bootpart=p2 swappart=p3 targetpart=p3
				[ ${swapsize:-0} -gt 0 ] && targetpart=p4
			else
				bootpart=p2 swappart=p2 targetpart=p2
				[ ${swapsize:-0} -gt 0 ] && targetpart=p3
			fi
		fi

		#
		#
		if [ "$ZFSBOOT_BOOT_POOL" ]; then
			f_eval_catch $funcname gpart \
				"$GPART_ADD_ALIGN_LABEL_WITH_SIZE" \
				"$align_big" boot$index freebsd-zfs \
				${bootsize}b $disk || return $FAILURE
			f_eval_catch -d $funcname zpool "$ZPOOL_LABELCLEAR_F" \
				/dev/$disk$bootpart
			if [ "$ZFSBOOT_GELI_ENCRYPTION" ]; then
				f_eval_catch -d $funcname geli \
					"$GELI_DETACH_F" \
					/dev/$disk$targetpart
			fi
		fi

		#
		#
		if [ ${swapsize:-0} -gt 0 ]; then
			f_eval_catch $funcname gpart \
				"$GPART_ADD_ALIGN_LABEL_WITH_SIZE" \
				"$align_big" swap$index freebsd-swap \
				${swapsize}b $disk || return $FAILURE
			f_eval_catch -d $funcname zpool "$ZPOOL_LABELCLEAR_F" \
				/dev/$disk$swappart
		fi

		#
		#
		if [ "$ZFSBOOT_POOL_SIZE" ]; then
			f_eval_catch $funcname gpart "$GPART_ADD_ALIGN_LABEL_WITH_SIZE" \
					"$align_big" zfs$index freebsd-zfs $ZFSBOOT_POOL_SIZE $disk ||
					return $FAILURE
		else
			f_eval_catch $funcname gpart "$GPART_ADD_ALIGN_LABEL" \
					"$align_big" zfs$index freebsd-zfs $disk ||
					return $FAILURE
		fi
		f_eval_catch -d $funcname zpool "$ZPOOL_LABELCLEAR_F" \
		                /dev/$disk$targetpart
		;;

	MBR)
		f_dprintf "$funcname: Creating MBR layout..."
		#
		#
		[ "$ZFSBOOT_GELI_ENCRYPTION" ] && ZFSBOOT_BOOT_POOL=1
		#
		#
		f_eval_catch $funcname gpart "$GPART_CREATE" mbr $disk ||
			return $FAILURE
		f_eval_catch $funcname gpart "$GPART_BOOTCODE" /boot/mbr \
			$disk || return $FAILURE

		#
		#
		f_eval_catch $funcname gpart "$GPART_ADD_ALIGN" \
			"$align_small" freebsd $disk || return $FAILURE
		f_eval_catch $funcname gpart "$GPART_SET_ACTIVE" 1 $disk ||
			return $FAILURE
		f_eval_catch -d $funcname zpool "$ZPOOL_LABELCLEAR_F" \
			/dev/${disk}s1
		f_eval_catch -d $funcname gpart "$GPART_DESTROY_F" ${disk}s1

		#
		#
		f_eval_catch $funcname gpart "$GPART_CREATE" BSD ${disk}s1 ||
			return $FAILURE

		bootpart=s1a swappart=s1b targetpart=s1d mbrindex=4

		#
		#
		ZFSBOOT_BOOT_POOL=1
		f_eval_catch $funcname gpart \
			"$GPART_ADD_ALIGN_INDEX_WITH_SIZE" \
			"" 1 freebsd-zfs ${bootsize}b ${disk}s1 ||
			return $FAILURE
		f_eval_catch -d $funcname zpool "$ZPOOL_LABELCLEAR_F" \
			/dev/$disk$bootpart
		if [ "$ZFSBOOT_GELI_ENCRYPTION" ]; then
			f_eval_catch -d $funcname geli \
				"$GELI_DETACH_F" \
				/dev/$disk$targetpart
		fi

		#
		#
		if [ ${swapsize:-0} -gt 0 ]; then
			f_eval_catch $funcname gpart \
				"$GPART_ADD_ALIGN_INDEX_WITH_SIZE" \
				"$align_small" 2 freebsd-swap \
				${swapsize}b ${disk}s1 || return $FAILURE
			f_eval_catch -d $funcname zpool "$ZPOOL_LABELCLEAR_F" \
				/dev/${disk}s1b
		fi

		#
		#
		if [ "$ZFSBOOT_POOL_SIZE" ]; then
			f_eval_catch $funcname gpart "$GPART_ADD_ALIGN_INDEX_WITH_SIZE" \
					"$align_small" $mbrindex freebsd-zfs $ZFSBOOT_POOL_SIZE ${disk}s1 || return $FAILURE
		else
			f_eval_catch $funcname gpart "$GPART_ADD_ALIGN_INDEX" \
					"$align_small" $mbrindex freebsd-zfs ${disk}s1 || return $FAILURE
		fi
		f_eval_catch -d $funcname zpool "$ZPOOL_LABELCLEAR_F" \
		                /dev/$disk$targetpart # Pedantic
		f_eval_catch $funcname dd "$DD_WITH_OPTIONS" \
		             /boot/zfsboot /dev/${disk}s1 count=1 ||
		             return $FAILURE
		;;

	esac # $ZFSBOOT_PARTITION_SCHEME

	local swapsize
	f_expand_number "$ZFSBOOT_SWAP_SIZE" swapsize
	if [ "$isswapmirror" ]; then
	elif [ ${swapsize:-0} -eq 0 ]; then
	elif [ "$ZFSBOOT_SWAP_ENCRYPTION" -a "$ZFSBOOT_SWAP_MIRROR" ]; then
		f_eval_catch $funcname printf "$PRINTF_FSTAB" \
			/dev/mirror/swap.eli none swap sw 0 0 \
			$BSDINSTALL_TMPETC/fstab || return $FAILURE
		isswapmirror=1
	elif [ "$ZFSBOOT_SWAP_MIRROR" ]; then
		f_eval_catch $funcname printf "$PRINTF_FSTAB" \
			/dev/mirror/swap none swap sw 0 0 \
			$BSDINSTALL_TMPETC/fstab || return $FAILURE
		isswapmirror=1
	elif [ "$ZFSBOOT_SWAP_ENCRYPTION" ]; then
		f_eval_catch $funcname printf "$PRINTF_FSTAB" \
			/dev/$disk${swappart}.eli none swap sw 0 0 \
			$BSDINSTALL_TMPETC/fstab || return $FAILURE
	else
		f_eval_catch $funcname printf "$PRINTF_FSTAB" \
			/dev/$disk$swappart none swap sw 0 0 \
			$BSDINSTALL_TMPETC/fstab || return $FAILURE
	fi

	return $SUCCESS
}

#
#
zfs_create_boot() {
	local funcname=zfs_create_boot
	local zroot_name="$1"
	local zroot_vdevtype="$2"
	local zroot_vdevs= # Calculated below
	local swap_devs=   # Calculated below
	local boot_vdevs=  # Used for geli(8) and/or MBR layouts
	shift 2            # poolname vdev_type
	local disks="$*" disk
	local isswapmirror
	local bootpart targetpart swappart # Set by zfs_create_diskpart() below
	local create_options
	local efibootpart

	#
	#
	if [ ! "$zroot_name" ]; then
		f_dprintf "$funcname: NULL poolname"
		msg_error="$msg_error: $funcname" \
			f_show_err "$msg_null_poolname"
		return $FAILURE
	fi
	if [ $# -lt 1 ]; then
		f_dprintf "$funcname: missing disk arguments"
		msg_error="$msg_error: $funcname" \
			f_show_err "$msg_missing_disk_arguments"
		return $FAILURE
	fi
	f_dprintf "$funcname: poolname=[%s] vdev_type=[%s]" \
		"$zroot_name" "$zroot_vdevtype"

	#
	#
	f_dprintf "$funcname: Initializing temporary fstab(5) file..."
	f_eval_catch $funcname sh "$SHELL_TRUNCATE" $BSDINSTALL_TMPETC/fstab ||
		return $FAILURE
	f_eval_catch $funcname printf "$PRINTF_FSTAB" \
		"# Device" Mountpoint FStype Options Dump "Pass#" \
		$BSDINSTALL_TMPETC/fstab || return $FAILURE

	#
	#
	f_dprintf "$funcname: Expanding supplied size values..."
	local swapsize bootsize poolsize
	if ! f_expand_number "$ZFSBOOT_SWAP_SIZE" swapsize; then
		f_dprintf "$funcname: Invalid swap size \`%s'" \
			"$ZFSBOOT_SWAP_SIZE"
		f_show_err "$msg_invalid_swap_size" "$ZFSBOOT_SWAP_SIZE"
		return $FAILURE
	fi
	if ! f_expand_number "$ZFSBOOT_BOOT_POOL_SIZE" bootsize; then
		f_dprintf "$funcname: Invalid boot pool size \`%s'" \
			"$ZFSBOOT_BOOT_POOL_SIZE"
		f_show_err "$msg_invalid_boot_pool_size" \
			"$ZFSBOOT_BOOT_POOL_SIZE"
		return $FAILURE
	fi
	if [ "$ZFSBOOT_POOL_SIZE" ]; then
		if ! f_expand_number "$ZFSBOOT_POOL_SIZE" poolsize; then
			f_dprintf "$funcname: Invalid pool size \`%s'" \
				  "$ZFSBOOT_POOL_SIZE"
			f_show_err "$msg_invalid_pool_size" \
				   "$ZFSBOOT_POOL_SIZE"
		fi
		f_dprintf "$funcname: ZFSBOOT_POOL_SIZE=[%s] poolsize=[%s]" \
			  "$ZFSBOOT_POOL_SIZE" "$poolsize"
	fi
	f_dprintf "$funcname: ZFSBOOT_SWAP_SIZE=[%s] swapsize=[%s]" \
		"$ZFSBOOT_SWAP_SIZE" "$swapsize"
	f_dprintf "$funcname: ZFSBOOT_BOOT_POOL_SIZE=[%s] bootsize=[%s]" \
		"$ZFSBOOT_BOOT_POOL_SIZE" "$bootsize"

	#
	#
	#
	f_eval_catch -d $funcname zpool "$ZPOOL_DESTROY" "$zroot_name"

	#
	#
	f_dprintf "$funcname: Preparing disk partitions for ZFS pool..."

	if [ "$ZFSBOOT_FORCE_4K_SECTORS" ]; then
		f_dprintf "$funcname: With 4K sectors..."
		f_eval_catch $funcname sysctl "$SYSCTL_ZFS_MIN_ASHIFT_12" || return $FAILURE
		sysctl kern.geom.part.mbr.enforce_chs=0
	fi
	local n=0
	for disk in $disks; do
		zfs_create_diskpart $disk $n || return $FAILURE
		if [ "$ZFSBOOT_BOOT_POOL" ]; then
			boot_vdevs="$boot_vdevs $disk$bootpart"
		fi
		zroot_vdevs="$zroot_vdevs $disk$targetpart"
		if [ "$ZFSBOOT_GELI_ENCRYPTION" ]; then
			zroot_vdevs="$zroot_vdevs.eli"
		fi

		n=$(($n + 1))
	done # disks

	#
	#
	if [ "$ZFSBOOT_BOOT_POOL" ]; then
		local bootpool_vdevtype= # Calculated below
		local bootpool_options=  # Calculated below
		local bootpool_name="$ZFSBOOT_BOOT_POOL_NAME"
		local bootpool="$BSDINSTALL_CHROOT/$bootpool_name"
		local zroot_key="${ZFSBOOT_GELI_KEY_FILE#/}"

		f_dprintf "$funcname: Setting up boot pool..."
		[ "$ZFSBOOT_GELI_ENCRYPTION" ] &&
			f_dprintf "$funcname: For encrypted root disk..."

		f_eval_catch -d $funcname umount "$UMOUNT" "$BSDINSTALL_CHROOT"
		f_eval_catch $funcname mount "$MOUNT_TYPE" tmpfs none \
			$BSDINSTALL_CHROOT || return $FAILURE

		local nvdevs
		f_count nvdevs $boot_vdevs
		[ $nvdevs -gt 1 ] && bootpool_vdevtype=mirror

		create_options="$ZFSBOOT_BOOT_POOL_CREATE_OPTIONS"
		bootpool_options="-o altroot=$BSDINSTALL_CHROOT"
		bootpool_options="$bootpool_options $create_options"
		bootpool_options="$bootpool_options -m \"/$bootpool_name\" -f"
		f_eval_catch $funcname zpool "$ZPOOL_CREATE_WITH_OPTIONS" \
			"$bootpool_options" "$bootpool_name" \
			"$bootpool_vdevtype" "$boot_vdevs" ||
			return $FAILURE

		f_eval_catch $funcname mkdir "$MKDIR_P" "$bootpool/boot" ||
			return $FAILURE

		if [ "$ZFSBOOT_GELI_ENCRYPTION" ]; then
			f_eval_catch $funcname dd "$DD_WITH_OPTIONS" \
				/dev/random "$bootpool/$zroot_key" \
				"bs=4096 count=1" || return $FAILURE
			f_eval_catch $funcname chmod "$CHMOD_MODE" \
				go-wrx "$bootpool/$zroot_key" ||
				return $FAILURE
		fi

	fi

	#
	#
	if [ "$ZFSBOOT_GELI_ENCRYPTION" ]; then
		#
		#
		f_eval_catch -d $funcname kldload "$KLDLOAD" "aesni"

		if [ -n "$_CONF_FREEBSD_INSTALLER_GELI_PASSPHRASE" ]; then
			pw_password="$_CONF_FREEBSD_INSTALLER_GELI_PASSPHRASE"
		else
			if ! msg_enter_new_password="$msg_geli_password" \
				f_dialog_input_password; then
				f_dprintf "$funcname: User cancelled"
				f_show_err "$msg_user_cancelled"
				return $FAILURE
			fi
		fi

		for disk in $disks; do
			f_dialog_info "$msg_geli_setup" \
				2>&1 >&$DIALOG_TERMINAL_PASSTHRU_FD
			if [ "$ZFSBOOT_BOOT_POOL" ]; then
				if ! echo "$pw_password" | f_eval_catch \
					$funcname geli "$GELI_PASSWORD_INIT" \
					"$bootpool/boot/$disk$targetpart.eli" \
					AES-XTS "$bootpool/$zroot_key" \
					$disk$targetpart; then
					f_interactive || f_die
					unset pw_password # Sensitive info
					return $FAILURE
				fi
				if ! echo "$pw_password" | f_eval_catch \
					$funcname geli "$GELI_ATTACH" \
					"$bootpool/$zroot_key" $disk$targetpart; then
					f_interactive || f_die
					unset pw_password # Sensitive info
					return $FAILURE
				fi
			else
				if ! echo "$pw_password" | f_eval_catch \
					$funcname geli \
					"$GELI_PASSWORD_GELIBOOT_INIT" \
					AES-XTS $disk$targetpart; then
					f_interactive || f_die
					unset pw_password # Sensitive info
					return $FAILURE
				fi
				if ! echo "$pw_password" | f_eval_catch \
					$funcname geli "$GELI_ATTACH_NOKEY" \
					$disk$targetpart; then
					f_interactive || f_die
					unset pw_password # Sensitive info
					return $FAILURE
				fi
			fi
		done
		unset pw_password # Sensitive info
	fi

	if [ "$ZFSBOOT_BOOT_POOL" ]; then
		f_eval_catch $funcname zfs "$ZFS_UNMOUNT" "$bootpool_name" ||
			return $FAILURE
		f_eval_catch -d $funcname umount "$UMOUNT" "$BSDINSTALL_CHROOT"
	fi

	#
	#
	if [ ${swapsize:-0} -gt 0 -a "$ZFSBOOT_SWAP_MIRROR" ]; then
		for disk in $disks; do
			swap_devs="$swap_devs $disk$swappart"
		done
		f_eval_catch $funcname gmirror "$SWAP_GMIRROR_LABEL" \
			"$swap_devs" || return $FAILURE
	fi

	#
	#
	f_dprintf "$funcname: Creating root pool..."
	create_options="$ZFSBOOT_POOL_CREATE_OPTIONS"
	if [ "$zroot_vdevtype" == "raid10" ]; then
		raid10_vdevs=""
		for vdev in $zroot_vdevs; do
			f_count nvdev $raid10_vdevs
			if [ $(($nvdev % 3)) -eq 0 ]; then
				raid10_vdevs="$raid10_vdevs mirror"
			fi
			raid10_vdevs="$raid10_vdevs $vdev"
		done
		f_eval_catch $funcname zpool "$ZPOOL_CREATE_WITH_OPTIONS" \
			"-o altroot=$BSDINSTALL_CHROOT $create_options -m none -f" \
			"$zroot_name" "" "$raid10_vdevs" || return $FAILURE
	else
		f_eval_catch $funcname zpool "$ZPOOL_CREATE_WITH_OPTIONS" \
			"-o altroot=$BSDINSTALL_CHROOT $create_options -m none -f" \
			"$zroot_name" "$zroot_vdevtype" "$zroot_vdevs" ||
			return $FAILURE
	fi

	#
	#
	f_dprintf "$funcname: Creating ZFS datasets..."
	echo "$ZFSBOOT_DATASETS" | while read dataset options; do
		case "$dataset" in "#"* | "") continue ;; esac
		options="${options%%#*}"
		f_replaceall "$options" "	" " " options
		oldoptions=
		while [ "$oldoptions" != "$options" ]; do
			oldoptions="$options"
			f_replaceall "$options" "  " " " options
		done
		f_replaceall "$options" "[ ,]" " -o " options
		f_eval_catch $funcname zfs "$ZFS_CREATE_WITH_OPTIONS" \
			"${options:+-o $options}" "$zroot_name$dataset" ||
			return $FAILURE
	done

	#
	#
	f_dprintf "$funcname: Setting mountpoint for root of the pool..."
	f_eval_catch $funcname zfs "$ZFS_SET" \
		"mountpoint=/$zroot_name" "$zroot_name" || return $FAILURE

	f_dprintf "$funcname: Modifying directory permissions..."
	local dir
	for dir in /tmp /var/tmp; do
		f_eval_catch $funcname mkdir "$MKDIR_P" \
			$BSDINSTALL_CHROOT$dir || return $FAILURE
		f_eval_catch $funcname chmod "$CHMOD_MODE" 1777 \
			$BSDINSTALL_CHROOT$dir || return $FAILURE
	done

	local zroot_bootfs="$ZFSBOOT_BEROOT_NAME/$ZFSBOOT_BOOTFS_NAME"
	f_dprintf "$funcname: Setting bootfs property..."
	f_eval_catch $funcname zpool "$ZPOOL_SET" \
		"bootfs=\"$zroot_name/$zroot_bootfs\"" "$zroot_name" ||
		return $FAILURE

	if [ "$ZFSBOOT_PARTITION_SCHEME" = "MBR" ]; then
		f_dprintf "$funcname: Temporarily exporting ZFS pool(s)..."
		f_eval_catch $funcname zpool "$ZPOOL_EXPORT" "$zroot_name" ||
			return $FAILURE
		if [ "$ZFSBOOT_BOOT_POOL" ]; then
			f_eval_catch $funcname zpool "$ZPOOL_EXPORT" \
				"$bootpool_name" || return $FAILURE
		fi

		f_dprintf "$funcname: Updating MBR boot loader on disks..."
		for disk in $disks; do
			f_eval_catch $funcname dd "$DD_WITH_OPTIONS" \
				/boot/zfsboot /dev/$disk$bootpart \
				"skip=1 seek=1024" || return $FAILURE
		done

		f_dprintf "$funcname: Re-importing ZFS pool(s)..."
		f_eval_catch $funcname zpool "$ZPOOL_IMPORT_WITH_OPTIONS" \
			"-o altroot=\"$BSDINSTALL_CHROOT\"" \
			"$zroot_name" || return $FAILURE
		if [ "$ZFSBOOT_BOOT_POOL" ]; then
			f_eval_catch $funcname zpool \
				"$ZPOOL_IMPORT_WITH_OPTIONS" \
				"-o altroot=\"$BSDINSTALL_CHROOT\" -N" \
				"$bootpool_name" || return $FAILURE
		fi
	fi

	if [ "$ZFSBOOT_BOOT_POOL" ]; then
		f_eval_catch $funcname zfs "$ZFS_MOUNT" "$bootpool_name" ||
			return $FAILURE
		f_dprintf "$funcname: Creating /boot symlink for boot pool..."
		f_eval_catch $funcname ln "$LN_SF" "$bootpool_name/boot" \
			$BSDINSTALL_CHROOT/boot || return $FAILURE
	fi

	f_dprintf "$funcname: Configuring zpool.cache for zroot..."
	f_eval_catch $funcname mkdir "$MKDIR_P" $BSDINSTALL_CHROOT/boot/zfs ||
		return $FAILURE
	f_eval_catch $funcname zpool "$ZPOOL_SET" \
		"cachefile=\"$BSDINSTALL_CHROOT/boot/zfs/zpool.cache\"" \
		"$zroot_name" || return $FAILURE

	if [ "$ZFSBOOT_BOOT_POOL" ]; then
		f_eval_catch $funcname printf "$PRINTF_CONF" \
			vfs.root.mountfrom \
			"\"zfs:$zroot_name/$zroot_bootfs\"" \
			$BSDINSTALL_TMPBOOT/loader.conf.root || return $FAILURE
	fi
	#
	#
	f_dprintf "$funcname: Set canmount=noauto for any datasets under the BE..."
	echo "$ZFSBOOT_DATASETS" | while read dataset options; do
		case "$dataset" in "#"*|"") continue; esac
		options="${options%%#*}"
		#
		case "$dataset" in "/$ZFSBOOT_BEROOT_NAME/$ZFSBOOT_BOOTFS_NAME"*)
			f_eval_catch $funcname zfs "$ZFS_SET" "canmount=noauto" \
				"$zroot_name$dataset" || return $FAILURE ;;
		*) continue ;;
		esac
	done

	f_dprintf "%s: Configuring rc.conf(5)/loader.conf(5) additions..." \
		"$funcname"
	f_eval_catch $funcname echo "$ECHO_APPEND" 'zfs_enable=\"YES\"' \
		$BSDINSTALL_TMPETC/rc.conf.zfs || return $FAILURE
	f_eval_catch $funcname echo "$ECHO_APPEND" \
		'kern.geom.label.disk_ident.enable=\"0\"' \
		$BSDINSTALL_TMPBOOT/loader.conf.zfs || return $FAILURE
	f_eval_catch $funcname echo "$ECHO_APPEND" \
		'kern.geom.label.gptid.enable=\"0\"' \
		$BSDINSTALL_TMPBOOT/loader.conf.zfs || return $FAILURE

	if [ "$ZFSBOOT_FORCE_4K_SECTORS" ]; then
		f_eval_catch $funcname echo "$ECHO_APPEND" \
			'vfs.zfs.min_auto_ashift=12' \
			$BSDINSTALL_TMPETC/sysctl.conf.zfs || return $FAILURE
	fi

	if [ "$ZFSBOOT_SWAP_MIRROR" ]; then
		f_eval_catch $funcname echo "$ECHO_APPEND" \
			'geom_mirror_load=\"YES\"' \
			$BSDINSTALL_TMPBOOT/loader.conf.gmirror ||
			return $FAILURE
	fi

	[ "$ZFSBOOT_GELI_ENCRYPTION" ] || return $SUCCESS

	#
	#
	f_dprintf "$funcname: Configuring disk encryption..."
	f_eval_catch $funcname echo "$ECHO_APPEND" 'aesni_load=\"YES\"' \
		$BSDINSTALL_TMPBOOT/loader.conf.aesni || return $FAILURE
	f_eval_catch $funcname echo "$ECHO_APPEND" 'geom_eli_load=\"YES\"' \
		$BSDINSTALL_TMPBOOT/loader.conf.geli || return $FAILURE

	[ "$ZFSBOOT_BOOT_POOL" ] || return $SUCCESS

	for disk in $disks; do
		f_eval_catch $funcname printf "$PRINTF_CONF" \
			geli_%s_keyfile0_load "$disk$targetpart YES" \
			$BSDINSTALL_TMPBOOT/loader.conf.$disk$targetpart ||
			return $FAILURE
		f_eval_catch $funcname printf "$PRINTF_CONF" \
			geli_%s_keyfile0_type \
			"$disk$targetpart $disk$targetpart:geli_keyfile0" \
			$BSDINSTALL_TMPBOOT/loader.conf.$disk$targetpart ||
			return $FAILURE
		f_eval_catch $funcname printf "$PRINTF_CONF" \
			geli_%s_keyfile0_name \
			"$disk$targetpart \"$ZFSBOOT_GELI_KEY_FILE\"" \
			$BSDINSTALL_TMPBOOT/loader.conf.$disk$targetpart ||
			return $FAILURE
	done

	f_dprintf "$funcname: Configuring zpool.cache for boot pool..."
	f_eval_catch $funcname zpool "$ZPOOL_SET" \
		"cachefile=\"$BSDINSTALL_CHROOT/boot/zfs/zpool.cache\"" \
		"$bootpool_name" || return $FAILURE

	for option in \
		'zpool_cache_load=\"YES\"' \
		'zpool_cache_type=\"/boot/zfs/zpool.cache\"' \
		'zpool_cache_name=\"/boot/zfs/zpool.cache\"' \
		'geom_eli_passphrase_prompt=\"YES\"'; do
		f_eval_catch $funcname echo "$ECHO_APPEND" "$option" \
			$BSDINSTALL_TMPBOOT/loader.conf.zfs ||
			return $FAILURE
	done
	return $SUCCESS
}

#
#
dialog_menu_diskinfo() {
	local device disk

	#
	#
	while :; do
		device=$(msg_cancel="$msg_back" f_device_menu \
			"$DIALOG_TITLE" "$msg_select_a_disk_device" "" \
			$DEVICE_TYPE_DISK 2>&1) || break
		$device get name disk

		f_show_msg "$msg_detailed_disk_info" \
			"$disk" "$(gpart show $disk 2>/dev/null)" \
			"$disk" "$(camcontrol inquiry $disk 2>/dev/null)" \
			"$disk" "$(camcontrol identify $disk 2>/dev/null)"
	done

	return $SUCCESS
}

dialog_zpool_name() {
	local prompt="$* is already taken, please enter a name for the ZFS pool \
	(Or confirm using the same name by just pressing enter)"
	local hline=
	local value="$*"
	local height width

	f_dialog_inputbox_size height width \
		"$DIALOG_TITLE" "$DIALOG_BACKTITLE" "$prompt" "$value" "$hline"

	$DIALOG \
		--title "$DIALOG_TITLE" \
		--backtitle "$DIALOG_BACKTITLE" \
		--hline "$hline" \
		--ok-label "Ok" \
		--no-cancel \
		--inputbox "$prompt" \
		$height $width "$value" \
		2>&1 >&$DIALOG_TERMINAL_PASSTHRU_FD
}


#
#
f_dialog_title "$msg_zfs_configuration"
f_dialog_backtitle "$msg_freebsd_installer"

! f_interactive && f_zfsinteractive && unset $VAR_NONINTERACTIVE

#
#
f_dprintf "BSDINSTALL_CHROOT=[%s]" "$BSDINSTALL_CHROOT"
f_dprintf "BSDINSTALL_TMPETC=[%s]" "$BSDINSTALL_TMPETC"
f_dprintf "FSTAB_FMT=[%s]" "$FSTAB_FMT"

pools=$(zpool import | awk '$1 == "pool:" { print $2}')
for pool in ${pools}; do
	f_dprintf "Checking ${pool} against ${ZFSBOOT_POOL_NAME}"
	if [ "${pool}" = "${ZFSBOOT_POOL_NAME}" ]; then
		f_dprintf "Pool ${pool} already taken"
		ZFSBOOT_POOL_NAME=$(dialog_zpool_name "${ZFSBOOT_POOL_NAME}")
		break
	fi
done

#
#
case $(uname -m) in
arm64 | riscv)
	: ${ZFSBOOT_BOOT_TYPE:=UEFI}
	: ${ZFSBOOT_PARTITION_SCHEME:=GPT}
	;;
*)
	bootmethod=$(sysctl -n machdep.bootmethod)
	f_dprintf "machdep.bootmethod=[%s]" "$bootmethod"
	if [ "$bootmethod" = "UEFI" ]; then
		: ${ZFSBOOT_BOOT_TYPE:=BIOS+UEFI}
		: ${ZFSBOOT_PARTITION_SCHEME:=GPT}
	else
		: ${ZFSBOOT_BOOT_TYPE:=BIOS}
		: ${ZFSBOOT_PARTITION_SCHEME:=GPT}
	fi
	;;
esac

#
#
while :; do
	if ! f_interactive; then
		retval=$DIALOG_OK
		mtag=">>> $msg_install"
	else
		dialog_menu_main
		retval=$?
		f_dialog_menutag_fetch mtag
	fi

	f_dprintf "retval=%u mtag=[%s]" $retval "$mtag"
	[ $retval -eq $DIALOG_OK ] || f_die

	case "$mtag" in
	">>> $msg_install")
		#
		#

		if [ ! "$ZFSBOOT_POOL_NAME" ]; then
			f_dprintf "Pool name cannot be empty."
			f_show_err "$msg_pool_name_cannot_be_empty"
			continue
		fi

		dialog_menu_layout || continue

		if f_expand_number "$ZFSBOOT_SWAP_SIZE" swapsize &&
		   f_expand_number "$ZFSBOOT_BOOT_POOL_SIZE" bootsize &&
		   f_expand_number "1g" zpoolmin
		then
			minsize=$swapsize teeny_disks=
			if [ "$ZFSBOOT_POOL_SIZE" ]; then
				f_expand_number "$ZFSBOOT_POOL_SIZE" poolsize
				minsize=$(( $minsize + $poolsize ))
			fi
			[ "$ZFSBOOT_BOOT_POOL" ] &&
				minsize=$(($minsize + $bootsize))
			for disk in $ZFSBOOT_DISKS; do
				debug= f_device_find -1 \
					$disk $DEVICE_TYPE_DISK device
				$device get capacity disksize || continue
				[ ${disksize:-0} -ge 0 ] || disksize=0
				[ $disksize -lt $minsize ] &&
					teeny_disks="$teeny_disks $disk"
			done
			if [ "$teeny_disks" ]; then
				f_dprintf "swapsize=[%s] bootsize[%s] %s" \
					"$ZFSBOOT_SWAP_SIZE" \
					"$ZFSBOOT_BOOT_POOL_SIZE" \
					"minsize=[$minsize]"
				f_dprintf "These disks are too small: %s" \
					"$teeny_disks"
				f_show_err "$msg_these_disks_are_too_small" \
					"$ZFSBOOT_SWAP_SIZE" \
					"$ZFSBOOT_BOOT_POOL_SIZE" \
					"$teeny_disks"
				continue
			fi
		fi

		#
		#
		if f_interactive; then
			dialog_last_chance $ZFSBOOT_DISKS || continue
		fi

		#
		#

		vdev_type="$ZFSBOOT_VDEV_TYPE"

		[ "$vdev_type" = "stripe" ] && vdev_type=

		zfs_create_boot "$ZFSBOOT_POOL_NAME" \
			"$vdev_type" $ZFSBOOT_DISKS || continue

		echo "$ZFSBOOT_DISKS" >${TMPDIR:-"/tmp"}/bsdinstall-zfsboot

		break # to success
		;;
	?" $msg_pool_type_disks")
		ZFSBOOT_CONFIRM_LAYOUT=1
		dialog_menu_layout
		ZFSBOOT_CONFIRM_LAYOUT=
		;;
	"- $msg_rescan_devices") f_device_rescan ;;
	"- $msg_disk_info") dialog_menu_diskinfo ;;
	?" $msg_pool_name")
		f_dialog_input input \
			"$msg_please_enter_a_name_for_your_zpool" \
			"$ZFSBOOT_POOL_NAME" &&
			ZFSBOOT_POOL_NAME="$input"
		;;
	?" $msg_force_4k_sectors")
		if [ "$ZFSBOOT_FORCE_4K_SECTORS" ]; then
			ZFSBOOT_FORCE_4K_SECTORS=
		else
			ZFSBOOT_FORCE_4K_SECTORS=1
		fi
		;;
	?" $msg_encrypt_disks")
		if [ "$ZFSBOOT_GELI_ENCRYPTION" ]; then
			ZFSBOOT_GELI_ENCRYPTION=
		else
			ZFSBOOT_FORCE_4K_SECTORS=1
			ZFSBOOT_GELI_ENCRYPTION=1
		fi
		;;
	?" $msg_partition_scheme")
		if [ "$ZFSBOOT_PARTITION_SCHEME" = "GPT" -a \
			"$ZFSBOOT_BOOT_TYPE" = "BIOS" ]; then
			ZFSBOOT_PARTITION_SCHEME="GPT"
			ZFSBOOT_BOOT_TYPE="UEFI"
		elif [ "$ZFSBOOT_PARTITION_SCHEME" = "GPT" -a \
			"$ZFSBOOT_BOOT_TYPE" = "UEFI" ]; then
			ZFSBOOT_PARTITION_SCHEME="GPT"
			ZFSBOOT_BOOT_TYPE="BIOS+UEFI"
		elif [ "$ZFSBOOT_PARTITION_SCHEME" = "GPT" ]; then
			ZFSBOOT_PARTITION_SCHEME="MBR"
			ZFSBOOT_BOOT_TYPE="BIOS"
		elif [ "$ZFSBOOT_PARTITION_SCHEME" = "MBR" ]; then
			ZFSBOOT_PARTITION_SCHEME="GPT + Active"
			ZFSBOOT_BOOT_TYPE="BIOS"
		elif [ "$ZFSBOOT_PARTITION_SCHEME" = "GPT + Active" ]; then
			ZFSBOOT_PARTITION_SCHEME="GPT + Lenovo Fix"
			ZFSBOOT_BOOT_TYPE="BIOS"
		else
			ZFSBOOT_PARTITION_SCHEME="GPT"
			ZFSBOOT_BOOT_TYPE="BIOS"
		fi
		;;
	?" $msg_swap_size")
		while :; do
			f_dialog_input input \
				"$msg_please_enter_amount_of_swap_space" \
				"$ZFSBOOT_SWAP_SIZE" &&
				ZFSBOOT_SWAP_SIZE="${input:-0}"
			if f_expand_number "$ZFSBOOT_SWAP_SIZE" swapsize; then
				if [ $swapsize -ne 0 -a $swapsize -lt 104857600 ]; then
					f_show_err "$msg_swap_toosmall" \
						"$ZFSBOOT_SWAP_SIZE"
					continue
				else
					break
				fi
			else
				f_show_err "$msg_swap_invalid" \
					"$ZFSBOOT_SWAP_SIZE"
				continue
			fi
		done
		;;
	?" $msg_swap_mirror")
		if [ "$ZFSBOOT_SWAP_MIRROR" ]; then
			ZFSBOOT_SWAP_MIRROR=
		else
			ZFSBOOT_SWAP_MIRROR=1
		fi
		;;
	?" $msg_swap_encrypt")
		if [ "$ZFSBOOT_SWAP_ENCRYPTION" ]; then
			ZFSBOOT_SWAP_ENCRYPTION=
		else
			ZFSBOOT_SWAP_ENCRYPTION=1
		fi
		;;
	esac
done

exit $SUCCESS

